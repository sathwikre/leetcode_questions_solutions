import java.util.*;

class Solution {

    public int networkDelayTime(int[][] times, int n, int k) {

        List<List<Pair>> adj = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }

        for (int i = 0; i < times.length; i++) {
            int src = times[i][0] - 1;
            int dest = times[i][1] - 1;
            int dist = times[i][2];

            adj.get(src).add(new Pair(dest, dist));
        }

        return dijkstra(adj, n, k - 1);
    }

    static int dijkstra(List<List<Pair>> adj, int n, int src) {

        int[] dist = new int[n];
        Arrays.fill(dist, (int) 1e9);
        dist[src] = 0;

        PriorityQueue<Pair> pq =
            new PriorityQueue<>((a, b) -> a.dist - b.dist);

        pq.add(new Pair(src, 0));

        while (!pq.isEmpty()) {
            Pair cur = pq.poll();
            int node = cur.node;
            int d = cur.dist;

            if (d > dist[node]) continue;

            for (Pair next : adj.get(node)) {
                int newDist = d + next.dist;
                if (newDist < dist[next.node]) {
                    dist[next.node] = newDist;
                    pq.add(new Pair(next.node, newDist));
                }
            }
        }

        int max = 0;
        for (int i = 0; i < n; i++) {
            if (dist[i] == (int) 1e9) return -1;
            max = Math.max(max, dist[i]);
        }
        return max;
    }
}

class Pair {
    int node;
    int dist;

    Pair(int node, int dist) {
        this.node = node;
        this.dist = dist;
    }
}
